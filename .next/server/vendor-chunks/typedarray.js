/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/typedarray";
exports.ids = ["vendor-chunks/typedarray"];
exports.modules = {

/***/ "(rsc)/./node_modules/typedarray/index.js":
/*!******************************************!*\
  !*** ./node_modules/typedarray/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var undefined = (void 0); // Paranoia\n\n// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to\n// create, and consume so much memory, that the browser appears frozen.\nvar MAX_ARRAY_LENGTH = 1e5;\n\n// Approximations of internal ECMAScript conversion functions\nvar ECMAScript = (function() {\n  // Stash a copy in case other scripts modify these\n  var opts = Object.prototype.toString,\n      ophop = Object.prototype.hasOwnProperty;\n\n  return {\n    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:\n    Class: function(v) { return opts.call(v).replace(/^\\[object *|\\]$/g, ''); },\n    HasProperty: function(o, p) { return p in o; },\n    HasOwnProperty: function(o, p) { return ophop.call(o, p); },\n    IsCallable: function(o) { return typeof o === 'function'; },\n    ToInt32: function(v) { return v >> 0; },\n    ToUint32: function(v) { return v >>> 0; }\n  };\n}());\n\n// Snapshot intrinsics\nvar LN2 = Math.LN2,\n    abs = Math.abs,\n    floor = Math.floor,\n    log = Math.log,\n    min = Math.min,\n    pow = Math.pow,\n    round = Math.round;\n\n// ES5: lock down object properties\nfunction configureProperties(obj) {\n  if (getOwnPropNames && defineProp) {\n    var props = getOwnPropNames(obj), i;\n    for (i = 0; i < props.length; i += 1) {\n      defineProp(obj, props[i], {\n        value: obj[props[i]],\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n    }\n  }\n}\n\n// emulate ES5 getter/setter API using legacy APIs\n// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx\n// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but\n// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)\nvar defineProp\nif (Object.defineProperty && (function() {\n      try {\n        Object.defineProperty({}, 'x', {});\n        return true;\n      } catch (e) {\n        return false;\n      }\n    })()) {\n  defineProp = Object.defineProperty;\n} else {\n  defineProp = function(o, p, desc) {\n    if (!o === Object(o)) throw new TypeError(\"Object.defineProperty called on non-object\");\n    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }\n    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }\n    if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }\n    return o;\n  };\n}\n\nvar getOwnPropNames = Object.getOwnPropertyNames || function (o) {\n  if (o !== Object(o)) throw new TypeError(\"Object.getOwnPropertyNames called on non-object\");\n  var props = [], p;\n  for (p in o) {\n    if (ECMAScript.HasOwnProperty(o, p)) {\n      props.push(p);\n    }\n  }\n  return props;\n};\n\n// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)\n// for index in 0 ... obj.length\nfunction makeArrayAccessors(obj) {\n  if (!defineProp) { return; }\n\n  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError(\"Array too large for polyfill\");\n\n  function makeArrayAccessor(index) {\n    defineProp(obj, index, {\n      'get': function() { return obj._getter(index); },\n      'set': function(v) { obj._setter(index, v); },\n      enumerable: true,\n      configurable: false\n    });\n  }\n\n  var i;\n  for (i = 0; i < obj.length; i += 1) {\n    makeArrayAccessor(i);\n  }\n}\n\n// Internal conversion functions:\n//    pack<Type>()   - take a number (interpreted as Type), output a byte array\n//    unpack<Type>() - take a byte array, output a Type-like number\n\nfunction as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }\nfunction as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }\n\nfunction packI8(n) { return [n & 0xff]; }\nfunction unpackI8(bytes) { return as_signed(bytes[0], 8); }\n\nfunction packU8(n) { return [n & 0xff]; }\nfunction unpackU8(bytes) { return as_unsigned(bytes[0], 8); }\n\nfunction packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }\n\nfunction packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }\nfunction unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }\n\nfunction packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }\nfunction unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }\n\nfunction packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }\nfunction unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }\n\nfunction packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }\nfunction unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }\n\nfunction packIEEE754(v, ebits, fbits) {\n\n  var bias = (1 << (ebits - 1)) - 1,\n      s, e, f, ln,\n      i, bits, str, bytes;\n\n  function roundToEven(n) {\n    var w = floor(n), f = n - w;\n    if (f < 0.5)\n      return w;\n    if (f > 0.5)\n      return w + 1;\n    return w % 2 ? w + 1 : w;\n  }\n\n  // Compute sign, exponent, fraction\n  if (v !== v) {\n    // NaN\n    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping\n    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;\n  } else if (v === Infinity || v === -Infinity) {\n    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;\n  } else if (v === 0) {\n    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;\n  } else {\n    s = v < 0;\n    v = abs(v);\n\n    if (v >= pow(2, 1 - bias)) {\n      e = min(floor(log(v) / LN2), 1023);\n      f = roundToEven(v / pow(2, e) * pow(2, fbits));\n      if (f / pow(2, fbits) >= 2) {\n        e = e + 1;\n        f = 1;\n      }\n      if (e > bias) {\n        // Overflow\n        e = (1 << ebits) - 1;\n        f = 0;\n      } else {\n        // Normalized\n        e = e + bias;\n        f = f - pow(2, fbits);\n      }\n    } else {\n      // Denormalized\n      e = 0;\n      f = roundToEven(v / pow(2, 1 - bias - fbits));\n    }\n  }\n\n  // Pack sign, exponent, fraction\n  bits = [];\n  for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }\n  for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }\n  bits.push(s ? 1 : 0);\n  bits.reverse();\n  str = bits.join('');\n\n  // Bits to bytes\n  bytes = [];\n  while (str.length) {\n    bytes.push(parseInt(str.substring(0, 8), 2));\n    str = str.substring(8);\n  }\n  return bytes;\n}\n\nfunction unpackIEEE754(bytes, ebits, fbits) {\n\n  // Bytes to bits\n  var bits = [], i, j, b, str,\n      bias, s, e, f;\n\n  for (i = bytes.length; i; i -= 1) {\n    b = bytes[i - 1];\n    for (j = 8; j; j -= 1) {\n      bits.push(b % 2 ? 1 : 0); b = b >> 1;\n    }\n  }\n  bits.reverse();\n  str = bits.join('');\n\n  // Unpack sign, exponent, fraction\n  bias = (1 << (ebits - 1)) - 1;\n  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n  e = parseInt(str.substring(1, 1 + ebits), 2);\n  f = parseInt(str.substring(1 + ebits), 2);\n\n  // Produce number\n  if (e === (1 << ebits) - 1) {\n    return f !== 0 ? NaN : s * Infinity;\n  } else if (e > 0) {\n    // Normalized\n    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));\n  } else if (f !== 0) {\n    // Denormalized\n    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));\n  } else {\n    return s < 0 ? -0 : 0;\n  }\n}\n\nfunction unpackF64(b) { return unpackIEEE754(b, 11, 52); }\nfunction packF64(v) { return packIEEE754(v, 11, 52); }\nfunction unpackF32(b) { return unpackIEEE754(b, 8, 23); }\nfunction packF32(v) { return packIEEE754(v, 8, 23); }\n\n\n//\n// 3 The ArrayBuffer Type\n//\n\n(function() {\n\n  /** @constructor */\n  var ArrayBuffer = function ArrayBuffer(length) {\n    length = ECMAScript.ToInt32(length);\n    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');\n\n    this.byteLength = length;\n    this._bytes = [];\n    this._bytes.length = length;\n\n    var i;\n    for (i = 0; i < this.byteLength; i += 1) {\n      this._bytes[i] = 0;\n    }\n\n    configureProperties(this);\n  };\n\n  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;\n\n  //\n  // 4 The ArrayBufferView Type\n  //\n\n  // NOTE: this constructor is not exported\n  /** @constructor */\n  var ArrayBufferView = function ArrayBufferView() {\n    //this.buffer = null;\n    //this.byteOffset = 0;\n    //this.byteLength = 0;\n  };\n\n  //\n  // 5 The Typed Array View Types\n  //\n\n  function makeConstructor(bytesPerElement, pack, unpack) {\n    // Each TypedArray type requires a distinct constructor instance with\n    // identical logic, which this produces.\n\n    var ctor;\n    ctor = function(buffer, byteOffset, length) {\n      var array, sequence, i, s;\n\n      if (!arguments.length || typeof arguments[0] === 'number') {\n        // Constructor(unsigned long length)\n        this.length = ECMAScript.ToInt32(arguments[0]);\n        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');\n\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {\n        // Constructor(TypedArray array)\n        array = arguments[0];\n\n        this.length = array.length;\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n\n        for (i = 0; i < this.length; i += 1) {\n          this._setter(i, array._getter(i));\n        }\n      } else if (typeof arguments[0] === 'object' &&\n                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {\n        // Constructor(sequence<type> array)\n        sequence = arguments[0];\n\n        this.length = ECMAScript.ToUint32(sequence.length);\n        this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        this.buffer = new ArrayBuffer(this.byteLength);\n        this.byteOffset = 0;\n\n        for (i = 0; i < this.length; i += 1) {\n          s = sequence[i];\n          this._setter(i, Number(s));\n        }\n      } else if (typeof arguments[0] === 'object' &&\n                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {\n        // Constructor(ArrayBuffer buffer,\n        //             optional unsigned long byteOffset, optional unsigned long length)\n        this.buffer = buffer;\n\n        this.byteOffset = ECMAScript.ToUint32(byteOffset);\n        if (this.byteOffset > this.buffer.byteLength) {\n          throw new RangeError(\"byteOffset out of range\");\n        }\n\n        if (this.byteOffset % this.BYTES_PER_ELEMENT) {\n          // The given byteOffset must be a multiple of the element\n          // size of the specific type, otherwise an exception is raised.\n          throw new RangeError(\"ArrayBuffer length minus the byteOffset is not a multiple of the element size.\");\n        }\n\n        if (arguments.length < 3) {\n          this.byteLength = this.buffer.byteLength - this.byteOffset;\n\n          if (this.byteLength % this.BYTES_PER_ELEMENT) {\n            throw new RangeError(\"length of buffer minus byteOffset not a multiple of the element size\");\n          }\n          this.length = this.byteLength / this.BYTES_PER_ELEMENT;\n        } else {\n          this.length = ECMAScript.ToUint32(length);\n          this.byteLength = this.length * this.BYTES_PER_ELEMENT;\n        }\n\n        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {\n          throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\");\n        }\n      } else {\n        throw new TypeError(\"Unexpected argument type(s)\");\n      }\n\n      this.constructor = ctor;\n\n      configureProperties(this);\n      makeArrayAccessors(this);\n    };\n\n    ctor.prototype = new ArrayBufferView();\n    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;\n    ctor.prototype._pack = pack;\n    ctor.prototype._unpack = unpack;\n    ctor.BYTES_PER_ELEMENT = bytesPerElement;\n\n    // getter type (unsigned long index);\n    ctor.prototype._getter = function(index) {\n      if (arguments.length < 1) throw new SyntaxError(\"Not enough arguments\");\n\n      index = ECMAScript.ToUint32(index);\n      if (index >= this.length) {\n        return undefined;\n      }\n\n      var bytes = [], i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        bytes.push(this.buffer._bytes[o]);\n      }\n      return this._unpack(bytes);\n    };\n\n    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);\n    ctor.prototype.get = ctor.prototype._getter;\n\n    // setter void (unsigned long index, type value);\n    ctor.prototype._setter = function(index, value) {\n      if (arguments.length < 2) throw new SyntaxError(\"Not enough arguments\");\n\n      index = ECMAScript.ToUint32(index);\n      if (index >= this.length) {\n        return undefined;\n      }\n\n      var bytes = this._pack(value), i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        this.buffer._bytes[o] = bytes[i];\n      }\n    };\n\n    // void set(TypedArray array, optional unsigned long offset);\n    // void set(sequence<type> array, optional unsigned long offset);\n    ctor.prototype.set = function(index, value) {\n      if (arguments.length < 1) throw new SyntaxError(\"Not enough arguments\");\n      var array, sequence, offset, len,\n          i, s, d,\n          byteOffset, byteLength, tmp;\n\n      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {\n        // void set(TypedArray array, optional unsigned long offset);\n        array = arguments[0];\n        offset = ECMAScript.ToUint32(arguments[1]);\n\n        if (offset + array.length > this.length) {\n          throw new RangeError(\"Offset plus length of array is out of range\");\n        }\n\n        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;\n        byteLength = array.length * this.BYTES_PER_ELEMENT;\n\n        if (array.buffer === this.buffer) {\n          tmp = [];\n          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {\n            tmp[i] = array.buffer._bytes[s];\n          }\n          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {\n            this.buffer._bytes[d] = tmp[i];\n          }\n        } else {\n          for (i = 0, s = array.byteOffset, d = byteOffset;\n               i < byteLength; i += 1, s += 1, d += 1) {\n            this.buffer._bytes[d] = array.buffer._bytes[s];\n          }\n        }\n      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {\n        // void set(sequence<type> array, optional unsigned long offset);\n        sequence = arguments[0];\n        len = ECMAScript.ToUint32(sequence.length);\n        offset = ECMAScript.ToUint32(arguments[1]);\n\n        if (offset + len > this.length) {\n          throw new RangeError(\"Offset plus length of array is out of range\");\n        }\n\n        for (i = 0; i < len; i += 1) {\n          s = sequence[i];\n          this._setter(offset + i, Number(s));\n        }\n      } else {\n        throw new TypeError(\"Unexpected argument type(s)\");\n      }\n    };\n\n    // TypedArray subarray(long begin, optional long end);\n    ctor.prototype.subarray = function(start, end) {\n      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n      start = ECMAScript.ToInt32(start);\n      end = ECMAScript.ToInt32(end);\n\n      if (arguments.length < 1) { start = 0; }\n      if (arguments.length < 2) { end = this.length; }\n\n      if (start < 0) { start = this.length + start; }\n      if (end < 0) { end = this.length + end; }\n\n      start = clamp(start, 0, this.length);\n      end = clamp(end, 0, this.length);\n\n      var len = end - start;\n      if (len < 0) {\n        len = 0;\n      }\n\n      return new this.constructor(\n        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);\n    };\n\n    return ctor;\n  }\n\n  var Int8Array = makeConstructor(1, packI8, unpackI8);\n  var Uint8Array = makeConstructor(1, packU8, unpackU8);\n  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);\n  var Int16Array = makeConstructor(2, packI16, unpackI16);\n  var Uint16Array = makeConstructor(2, packU16, unpackU16);\n  var Int32Array = makeConstructor(4, packI32, unpackI32);\n  var Uint32Array = makeConstructor(4, packU32, unpackU32);\n  var Float32Array = makeConstructor(4, packF32, unpackF32);\n  var Float64Array = makeConstructor(8, packF64, unpackF64);\n\n  exports.Int8Array = exports.Int8Array || Int8Array;\n  exports.Uint8Array = exports.Uint8Array || Uint8Array;\n  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;\n  exports.Int16Array = exports.Int16Array || Int16Array;\n  exports.Uint16Array = exports.Uint16Array || Uint16Array;\n  exports.Int32Array = exports.Int32Array || Int32Array;\n  exports.Uint32Array = exports.Uint32Array || Uint32Array;\n  exports.Float32Array = exports.Float32Array || Float32Array;\n  exports.Float64Array = exports.Float64Array || Float64Array;\n}());\n\n//\n// 6 The DataView View Type\n//\n\n(function() {\n  function r(array, index) {\n    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];\n  }\n\n  var IS_BIG_ENDIAN = (function() {\n    var u16array = new(exports.Uint16Array)([0x1234]),\n        u8array = new(exports.Uint8Array)(u16array.buffer);\n    return r(u8array, 0) === 0x12;\n  }());\n\n  // Constructor(ArrayBuffer buffer,\n  //             optional unsigned long byteOffset,\n  //             optional unsigned long byteLength)\n  /** @constructor */\n  var DataView = function DataView(buffer, byteOffset, byteLength) {\n    if (arguments.length === 0) {\n      buffer = new exports.ArrayBuffer(0);\n    } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {\n      throw new TypeError(\"TypeError\");\n    }\n\n    this.buffer = buffer || new exports.ArrayBuffer(0);\n\n    this.byteOffset = ECMAScript.ToUint32(byteOffset);\n    if (this.byteOffset > this.buffer.byteLength) {\n      throw new RangeError(\"byteOffset out of range\");\n    }\n\n    if (arguments.length < 3) {\n      this.byteLength = this.buffer.byteLength - this.byteOffset;\n    } else {\n      this.byteLength = ECMAScript.ToUint32(byteLength);\n    }\n\n    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {\n      throw new RangeError(\"byteOffset and length reference an area beyond the end of the buffer\");\n    }\n\n    configureProperties(this);\n  };\n\n  function makeGetter(arrayType) {\n    return function(byteOffset, littleEndian) {\n\n      byteOffset = ECMAScript.ToUint32(byteOffset);\n\n      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {\n        throw new RangeError(\"Array index out of range\");\n      }\n      byteOffset += this.byteOffset;\n\n      var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),\n          bytes = [], i;\n      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {\n        bytes.push(r(uint8Array, i));\n      }\n\n      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {\n        bytes.reverse();\n      }\n\n      return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);\n    };\n  }\n\n  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);\n  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);\n  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);\n  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);\n  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);\n  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);\n  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);\n  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);\n\n  function makeSetter(arrayType) {\n    return function(byteOffset, value, littleEndian) {\n\n      byteOffset = ECMAScript.ToUint32(byteOffset);\n      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {\n        throw new RangeError(\"Array index out of range\");\n      }\n\n      // Get bytes\n      var typeArray = new arrayType([value]),\n          byteArray = new exports.Uint8Array(typeArray.buffer),\n          bytes = [], i, byteView;\n\n      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {\n        bytes.push(r(byteArray, i));\n      }\n\n      // Flip if necessary\n      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {\n        bytes.reverse();\n      }\n\n      // Write them\n      byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);\n      byteView.set(bytes);\n    };\n  }\n\n  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);\n  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);\n  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);\n  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);\n  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);\n  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);\n  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);\n  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);\n\n  exports.DataView = exports.DataView || DataView;\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQXNEO0FBQy9FLGtDQUFrQyxnQkFBZ0I7QUFDbEQscUNBQXFDLDBCQUEwQjtBQUMvRCw4QkFBOEIsaUNBQWlDO0FBQy9ELDJCQUEyQixnQkFBZ0I7QUFDM0MsNEJBQTRCO0FBQzVCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRixvRkFBb0Y7QUFDcEYsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3RELDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLG1CQUFtQjtBQUNyRCxvQ0FBb0MsbUJBQW1COztBQUV2RCxxQkFBcUI7QUFDckIsMkJBQTJCOztBQUUzQixxQkFBcUI7QUFDckIsMkJBQTJCOztBQUUzQiw0QkFBNEIsc0JBQXNC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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxnQkFBZ0I7O0FBRWxCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tdXNpYy1wbGF5ZXIvLi9ub2RlX21vZHVsZXMvdHlwZWRhcnJheS9pbmRleC5qcz8zOGFkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB1bmRlZmluZWQgPSAodm9pZCAwKTsgLy8gUGFyYW5vaWFcblxuLy8gQmV5b25kIHRoaXMgdmFsdWUsIGluZGV4IGdldHRlcnMvc2V0dGVycyAoaS5lLiBhcnJheVswXSwgYXJyYXlbMV0pIGFyZSBzbyBzbG93IHRvXG4vLyBjcmVhdGUsIGFuZCBjb25zdW1lIHNvIG11Y2ggbWVtb3J5LCB0aGF0IHRoZSBicm93c2VyIGFwcGVhcnMgZnJvemVuLlxudmFyIE1BWF9BUlJBWV9MRU5HVEggPSAxZTU7XG5cbi8vIEFwcHJveGltYXRpb25zIG9mIGludGVybmFsIEVDTUFTY3JpcHQgY29udmVyc2lvbiBmdW5jdGlvbnNcbnZhciBFQ01BU2NyaXB0ID0gKGZ1bmN0aW9uKCkge1xuICAvLyBTdGFzaCBhIGNvcHkgaW4gY2FzZSBvdGhlciBzY3JpcHRzIG1vZGlmeSB0aGVzZVxuICB2YXIgb3B0cyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICBvcGhvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBDbGFzcyByZXR1cm5zIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSwgdXNlZCB0byBhdm9pZCBjcm9zcy1mcmFtZSBpbnN0YW5jZW9mIGlzc3VlczpcbiAgICBDbGFzczogZnVuY3Rpb24odikgeyByZXR1cm4gb3B0cy5jYWxsKHYpLnJlcGxhY2UoL15cXFtvYmplY3QgKnxcXF0kL2csICcnKTsgfSxcbiAgICBIYXNQcm9wZXJ0eTogZnVuY3Rpb24obywgcCkgeyByZXR1cm4gcCBpbiBvOyB9LFxuICAgIEhhc093blByb3BlcnR5OiBmdW5jdGlvbihvLCBwKSB7IHJldHVybiBvcGhvcC5jYWxsKG8sIHApOyB9LFxuICAgIElzQ2FsbGFibGU6IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIHR5cGVvZiBvID09PSAnZnVuY3Rpb24nOyB9LFxuICAgIFRvSW50MzI6IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYgPj4gMDsgfSxcbiAgICBUb1VpbnQzMjogZnVuY3Rpb24odikgeyByZXR1cm4gdiA+Pj4gMDsgfVxuICB9O1xufSgpKTtcblxuLy8gU25hcHNob3QgaW50cmluc2ljc1xudmFyIExOMiA9IE1hdGguTE4yLFxuICAgIGFicyA9IE1hdGguYWJzLFxuICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICBsb2cgPSBNYXRoLmxvZyxcbiAgICBtaW4gPSBNYXRoLm1pbixcbiAgICBwb3cgPSBNYXRoLnBvdyxcbiAgICByb3VuZCA9IE1hdGgucm91bmQ7XG5cbi8vIEVTNTogbG9jayBkb3duIG9iamVjdCBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBjb25maWd1cmVQcm9wZXJ0aWVzKG9iaikge1xuICBpZiAoZ2V0T3duUHJvcE5hbWVzICYmIGRlZmluZVByb3ApIHtcbiAgICB2YXIgcHJvcHMgPSBnZXRPd25Qcm9wTmFtZXMob2JqKSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGRlZmluZVByb3Aob2JqLCBwcm9wc1tpXSwge1xuICAgICAgICB2YWx1ZTogb2JqW3Byb3BzW2ldXSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8vIGVtdWxhdGUgRVM1IGdldHRlci9zZXR0ZXIgQVBJIHVzaW5nIGxlZ2FjeSBBUElzXG4vLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZS9hcmNoaXZlLzIwMTAvMDkvMDcvdHJhbnNpdGlvbmluZy1leGlzdGluZy1jb2RlLXRvLXRoZS1lczUtZ2V0dGVyLXNldHRlci1hcGlzLmFzcHhcbi8vIChzZWNvbmQgY2xhdXNlIHRlc3RzIGZvciBPYmplY3QuZGVmaW5lUHJvcGVydHkoKSBpbiBJRTw5IHRoYXQgb25seSBzdXBwb3J0cyBleHRlbmRpbmcgRE9NIHByb3RvdHlwZXMsIGJ1dFxuLy8gbm90ZSB0aGF0IElFPDkgZG9lcyBub3Qgc3VwcG9ydCBfX2RlZmluZUdldHRlcl9fIG9yIF9fZGVmaW5lU2V0dGVyX18gc28gaXQganVzdCByZW5kZXJzIHRoZSBtZXRob2QgaGFybWxlc3MpXG52YXIgZGVmaW5lUHJvcFxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge30pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pKCkpIHtcbiAgZGVmaW5lUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbn0gZWxzZSB7XG4gIGRlZmluZVByb3AgPSBmdW5jdGlvbihvLCBwLCBkZXNjKSB7XG4gICAgaWYgKCFvID09PSBPYmplY3QobykpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbGVkIG9uIG5vbi1vYmplY3RcIik7XG4gICAgaWYgKEVDTUFTY3JpcHQuSGFzUHJvcGVydHkoZGVzYywgJ2dldCcpICYmIE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXykgeyBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18uY2FsbChvLCBwLCBkZXNjLmdldCk7IH1cbiAgICBpZiAoRUNNQVNjcmlwdC5IYXNQcm9wZXJ0eShkZXNjLCAnc2V0JykgJiYgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fKSB7IE9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfXy5jYWxsKG8sIHAsIGRlc2Muc2V0KTsgfVxuICAgIGlmIChFQ01BU2NyaXB0Lkhhc1Byb3BlcnR5KGRlc2MsICd2YWx1ZScpKSB7IG9bcF0gPSBkZXNjLnZhbHVlOyB9XG4gICAgcmV0dXJuIG87XG4gIH07XG59XG5cbnZhciBnZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICBpZiAobyAhPT0gT2JqZWN0KG8pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgY2FsbGVkIG9uIG5vbi1vYmplY3RcIik7XG4gIHZhciBwcm9wcyA9IFtdLCBwO1xuICBmb3IgKHAgaW4gbykge1xuICAgIGlmIChFQ01BU2NyaXB0Lkhhc093blByb3BlcnR5KG8sIHApKSB7XG4gICAgICBwcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcHM7XG59O1xuXG4vLyBFUzU6IE1ha2Ugb2JqW2luZGV4XSBhbiBhbGlhcyBmb3Igb2JqLl9nZXR0ZXIoaW5kZXgpL29iai5fc2V0dGVyKGluZGV4LCB2YWx1ZSlcbi8vIGZvciBpbmRleCBpbiAwIC4uLiBvYmoubGVuZ3RoXG5mdW5jdGlvbiBtYWtlQXJyYXlBY2Nlc3NvcnMob2JqKSB7XG4gIGlmICghZGVmaW5lUHJvcCkgeyByZXR1cm47IH1cblxuICBpZiAob2JqLmxlbmd0aCA+IE1BWF9BUlJBWV9MRU5HVEgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXJyYXkgdG9vIGxhcmdlIGZvciBwb2x5ZmlsbFwiKTtcblxuICBmdW5jdGlvbiBtYWtlQXJyYXlBY2Nlc3NvcihpbmRleCkge1xuICAgIGRlZmluZVByb3Aob2JqLCBpbmRleCwge1xuICAgICAgJ2dldCc6IGZ1bmN0aW9uKCkgeyByZXR1cm4gb2JqLl9nZXR0ZXIoaW5kZXgpOyB9LFxuICAgICAgJ3NldCc6IGZ1bmN0aW9uKHYpIHsgb2JqLl9zZXR0ZXIoaW5kZXgsIHYpOyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgbWFrZUFycmF5QWNjZXNzb3IoaSk7XG4gIH1cbn1cblxuLy8gSW50ZXJuYWwgY29udmVyc2lvbiBmdW5jdGlvbnM6XG4vLyAgICBwYWNrPFR5cGU+KCkgICAtIHRha2UgYSBudW1iZXIgKGludGVycHJldGVkIGFzIFR5cGUpLCBvdXRwdXQgYSBieXRlIGFycmF5XG4vLyAgICB1bnBhY2s8VHlwZT4oKSAtIHRha2UgYSBieXRlIGFycmF5LCBvdXRwdXQgYSBUeXBlLWxpa2UgbnVtYmVyXG5cbmZ1bmN0aW9uIGFzX3NpZ25lZCh2YWx1ZSwgYml0cykgeyB2YXIgcyA9IDMyIC0gYml0czsgcmV0dXJuICh2YWx1ZSA8PCBzKSA+PiBzOyB9XG5mdW5jdGlvbiBhc191bnNpZ25lZCh2YWx1ZSwgYml0cykgeyB2YXIgcyA9IDMyIC0gYml0czsgcmV0dXJuICh2YWx1ZSA8PCBzKSA+Pj4gczsgfVxuXG5mdW5jdGlvbiBwYWNrSTgobikgeyByZXR1cm4gW24gJiAweGZmXTsgfVxuZnVuY3Rpb24gdW5wYWNrSTgoYnl0ZXMpIHsgcmV0dXJuIGFzX3NpZ25lZChieXRlc1swXSwgOCk7IH1cblxuZnVuY3Rpb24gcGFja1U4KG4pIHsgcmV0dXJuIFtuICYgMHhmZl07IH1cbmZ1bmN0aW9uIHVucGFja1U4KGJ5dGVzKSB7IHJldHVybiBhc191bnNpZ25lZChieXRlc1swXSwgOCk7IH1cblxuZnVuY3Rpb24gcGFja1U4Q2xhbXBlZChuKSB7IG4gPSByb3VuZChOdW1iZXIobikpOyByZXR1cm4gW24gPCAwID8gMCA6IG4gPiAweGZmID8gMHhmZiA6IG4gJiAweGZmXTsgfVxuXG5mdW5jdGlvbiBwYWNrSTE2KG4pIHsgcmV0dXJuIFsobiA+PiA4KSAmIDB4ZmYsIG4gJiAweGZmXTsgfVxuZnVuY3Rpb24gdW5wYWNrSTE2KGJ5dGVzKSB7IHJldHVybiBhc19zaWduZWQoYnl0ZXNbMF0gPDwgOCB8IGJ5dGVzWzFdLCAxNik7IH1cblxuZnVuY3Rpb24gcGFja1UxNihuKSB7IHJldHVybiBbKG4gPj4gOCkgJiAweGZmLCBuICYgMHhmZl07IH1cbmZ1bmN0aW9uIHVucGFja1UxNihieXRlcykgeyByZXR1cm4gYXNfdW5zaWduZWQoYnl0ZXNbMF0gPDwgOCB8IGJ5dGVzWzFdLCAxNik7IH1cblxuZnVuY3Rpb24gcGFja0kzMihuKSB7IHJldHVybiBbKG4gPj4gMjQpICYgMHhmZiwgKG4gPj4gMTYpICYgMHhmZiwgKG4gPj4gOCkgJiAweGZmLCBuICYgMHhmZl07IH1cbmZ1bmN0aW9uIHVucGFja0kzMihieXRlcykgeyByZXR1cm4gYXNfc2lnbmVkKGJ5dGVzWzBdIDw8IDI0IHwgYnl0ZXNbMV0gPDwgMTYgfCBieXRlc1syXSA8PCA4IHwgYnl0ZXNbM10sIDMyKTsgfVxuXG5mdW5jdGlvbiBwYWNrVTMyKG4pIHsgcmV0dXJuIFsobiA+PiAyNCkgJiAweGZmLCAobiA+PiAxNikgJiAweGZmLCAobiA+PiA4KSAmIDB4ZmYsIG4gJiAweGZmXTsgfVxuZnVuY3Rpb24gdW5wYWNrVTMyKGJ5dGVzKSB7IHJldHVybiBhc191bnNpZ25lZChieXRlc1swXSA8PCAyNCB8IGJ5dGVzWzFdIDw8IDE2IHwgYnl0ZXNbMl0gPDwgOCB8IGJ5dGVzWzNdLCAzMik7IH1cblxuZnVuY3Rpb24gcGFja0lFRUU3NTQodiwgZWJpdHMsIGZiaXRzKSB7XG5cbiAgdmFyIGJpYXMgPSAoMSA8PCAoZWJpdHMgLSAxKSkgLSAxLFxuICAgICAgcywgZSwgZiwgbG4sXG4gICAgICBpLCBiaXRzLCBzdHIsIGJ5dGVzO1xuXG4gIGZ1bmN0aW9uIHJvdW5kVG9FdmVuKG4pIHtcbiAgICB2YXIgdyA9IGZsb29yKG4pLCBmID0gbiAtIHc7XG4gICAgaWYgKGYgPCAwLjUpXG4gICAgICByZXR1cm4gdztcbiAgICBpZiAoZiA+IDAuNSlcbiAgICAgIHJldHVybiB3ICsgMTtcbiAgICByZXR1cm4gdyAlIDIgPyB3ICsgMSA6IHc7XG4gIH1cblxuICAvLyBDb21wdXRlIHNpZ24sIGV4cG9uZW50LCBmcmFjdGlvblxuICBpZiAodiAhPT0gdikge1xuICAgIC8vIE5hTlxuICAgIC8vIGh0dHA6Ly9kZXYudzMub3JnLzIwMDYvd2ViYXBpL1dlYklETC8jZXMtdHlwZS1tYXBwaW5nXG4gICAgZSA9ICgxIDw8IGViaXRzKSAtIDE7IGYgPSBwb3coMiwgZmJpdHMgLSAxKTsgcyA9IDA7XG4gIH0gZWxzZSBpZiAodiA9PT0gSW5maW5pdHkgfHwgdiA9PT0gLUluZmluaXR5KSB7XG4gICAgZSA9ICgxIDw8IGViaXRzKSAtIDE7IGYgPSAwOyBzID0gKHYgPCAwKSA/IDEgOiAwO1xuICB9IGVsc2UgaWYgKHYgPT09IDApIHtcbiAgICBlID0gMDsgZiA9IDA7IHMgPSAoMSAvIHYgPT09IC1JbmZpbml0eSkgPyAxIDogMDtcbiAgfSBlbHNlIHtcbiAgICBzID0gdiA8IDA7XG4gICAgdiA9IGFicyh2KTtcblxuICAgIGlmICh2ID49IHBvdygyLCAxIC0gYmlhcykpIHtcbiAgICAgIGUgPSBtaW4oZmxvb3IobG9nKHYpIC8gTE4yKSwgMTAyMyk7XG4gICAgICBmID0gcm91bmRUb0V2ZW4odiAvIHBvdygyLCBlKSAqIHBvdygyLCBmYml0cykpO1xuICAgICAgaWYgKGYgLyBwb3coMiwgZmJpdHMpID49IDIpIHtcbiAgICAgICAgZSA9IGUgKyAxO1xuICAgICAgICBmID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChlID4gYmlhcykge1xuICAgICAgICAvLyBPdmVyZmxvd1xuICAgICAgICBlID0gKDEgPDwgZWJpdHMpIC0gMTtcbiAgICAgICAgZiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWxpemVkXG4gICAgICAgIGUgPSBlICsgYmlhcztcbiAgICAgICAgZiA9IGYgLSBwb3coMiwgZmJpdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZW5vcm1hbGl6ZWRcbiAgICAgIGUgPSAwO1xuICAgICAgZiA9IHJvdW5kVG9FdmVuKHYgLyBwb3coMiwgMSAtIGJpYXMgLSBmYml0cykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFBhY2sgc2lnbiwgZXhwb25lbnQsIGZyYWN0aW9uXG4gIGJpdHMgPSBbXTtcbiAgZm9yIChpID0gZmJpdHM7IGk7IGkgLT0gMSkgeyBiaXRzLnB1c2goZiAlIDIgPyAxIDogMCk7IGYgPSBmbG9vcihmIC8gMik7IH1cbiAgZm9yIChpID0gZWJpdHM7IGk7IGkgLT0gMSkgeyBiaXRzLnB1c2goZSAlIDIgPyAxIDogMCk7IGUgPSBmbG9vcihlIC8gMik7IH1cbiAgYml0cy5wdXNoKHMgPyAxIDogMCk7XG4gIGJpdHMucmV2ZXJzZSgpO1xuICBzdHIgPSBiaXRzLmpvaW4oJycpO1xuXG4gIC8vIEJpdHMgdG8gYnl0ZXNcbiAgYnl0ZXMgPSBbXTtcbiAgd2hpbGUgKHN0ci5sZW5ndGgpIHtcbiAgICBieXRlcy5wdXNoKHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMCwgOCksIDIpKTtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDgpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cblxuZnVuY3Rpb24gdW5wYWNrSUVFRTc1NChieXRlcywgZWJpdHMsIGZiaXRzKSB7XG5cbiAgLy8gQnl0ZXMgdG8gYml0c1xuICB2YXIgYml0cyA9IFtdLCBpLCBqLCBiLCBzdHIsXG4gICAgICBiaWFzLCBzLCBlLCBmO1xuXG4gIGZvciAoaSA9IGJ5dGVzLmxlbmd0aDsgaTsgaSAtPSAxKSB7XG4gICAgYiA9IGJ5dGVzW2kgLSAxXTtcbiAgICBmb3IgKGogPSA4OyBqOyBqIC09IDEpIHtcbiAgICAgIGJpdHMucHVzaChiICUgMiA/IDEgOiAwKTsgYiA9IGIgPj4gMTtcbiAgICB9XG4gIH1cbiAgYml0cy5yZXZlcnNlKCk7XG4gIHN0ciA9IGJpdHMuam9pbignJyk7XG5cbiAgLy8gVW5wYWNrIHNpZ24sIGV4cG9uZW50LCBmcmFjdGlvblxuICBiaWFzID0gKDEgPDwgKGViaXRzIC0gMSkpIC0gMTtcbiAgcyA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMCwgMSksIDIpID8gLTEgOiAxO1xuICBlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZygxLCAxICsgZWJpdHMpLCAyKTtcbiAgZiA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoMSArIGViaXRzKSwgMik7XG5cbiAgLy8gUHJvZHVjZSBudW1iZXJcbiAgaWYgKGUgPT09ICgxIDw8IGViaXRzKSAtIDEpIHtcbiAgICByZXR1cm4gZiAhPT0gMCA/IE5hTiA6IHMgKiBJbmZpbml0eTtcbiAgfSBlbHNlIGlmIChlID4gMCkge1xuICAgIC8vIE5vcm1hbGl6ZWRcbiAgICByZXR1cm4gcyAqIHBvdygyLCBlIC0gYmlhcykgKiAoMSArIGYgLyBwb3coMiwgZmJpdHMpKTtcbiAgfSBlbHNlIGlmIChmICE9PSAwKSB7XG4gICAgLy8gRGVub3JtYWxpemVkXG4gICAgcmV0dXJuIHMgKiBwb3coMiwgLShiaWFzIC0gMSkpICogKGYgLyBwb3coMiwgZmJpdHMpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcyA8IDAgPyAtMCA6IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5wYWNrRjY0KGIpIHsgcmV0dXJuIHVucGFja0lFRUU3NTQoYiwgMTEsIDUyKTsgfVxuZnVuY3Rpb24gcGFja0Y2NCh2KSB7IHJldHVybiBwYWNrSUVFRTc1NCh2LCAxMSwgNTIpOyB9XG5mdW5jdGlvbiB1bnBhY2tGMzIoYikgeyByZXR1cm4gdW5wYWNrSUVFRTc1NChiLCA4LCAyMyk7IH1cbmZ1bmN0aW9uIHBhY2tGMzIodikgeyByZXR1cm4gcGFja0lFRUU3NTQodiwgOCwgMjMpOyB9XG5cblxuLy9cbi8vIDMgVGhlIEFycmF5QnVmZmVyIFR5cGVcbi8vXG5cbihmdW5jdGlvbigpIHtcblxuICAvKiogQGNvbnN0cnVjdG9yICovXG4gIHZhciBBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgIGxlbmd0aCA9IEVDTUFTY3JpcHQuVG9JbnQzMihsZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXJyYXlCdWZmZXIgc2l6ZSBpcyBub3QgYSBzbWFsbCBlbm91Z2ggcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgdGhpcy5ieXRlTGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX2J5dGVzID0gW107XG4gICAgdGhpcy5fYnl0ZXMubGVuZ3RoID0gbGVuZ3RoO1xuXG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYnl0ZUxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB0aGlzLl9ieXRlc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgY29uZmlndXJlUHJvcGVydGllcyh0aGlzKTtcbiAgfTtcblxuICBleHBvcnRzLkFycmF5QnVmZmVyID0gZXhwb3J0cy5BcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlcjtcblxuICAvL1xuICAvLyA0IFRoZSBBcnJheUJ1ZmZlclZpZXcgVHlwZVxuICAvL1xuXG4gIC8vIE5PVEU6IHRoaXMgY29uc3RydWN0b3IgaXMgbm90IGV4cG9ydGVkXG4gIC8qKiBAY29uc3RydWN0b3IgKi9cbiAgdmFyIEFycmF5QnVmZmVyVmlldyA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyVmlldygpIHtcbiAgICAvL3RoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAvL3RoaXMuYnl0ZU9mZnNldCA9IDA7XG4gICAgLy90aGlzLmJ5dGVMZW5ndGggPSAwO1xuICB9O1xuXG4gIC8vXG4gIC8vIDUgVGhlIFR5cGVkIEFycmF5IFZpZXcgVHlwZXNcbiAgLy9cblxuICBmdW5jdGlvbiBtYWtlQ29uc3RydWN0b3IoYnl0ZXNQZXJFbGVtZW50LCBwYWNrLCB1bnBhY2spIHtcbiAgICAvLyBFYWNoIFR5cGVkQXJyYXkgdHlwZSByZXF1aXJlcyBhIGRpc3RpbmN0IGNvbnN0cnVjdG9yIGluc3RhbmNlIHdpdGhcbiAgICAvLyBpZGVudGljYWwgbG9naWMsIHdoaWNoIHRoaXMgcHJvZHVjZXMuXG5cbiAgICB2YXIgY3RvcjtcbiAgICBjdG9yID0gZnVuY3Rpb24oYnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIHZhciBhcnJheSwgc2VxdWVuY2UsIGksIHM7XG5cbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBDb25zdHJ1Y3Rvcih1bnNpZ25lZCBsb25nIGxlbmd0aClcbiAgICAgICAgdGhpcy5sZW5ndGggPSBFQ01BU2NyaXB0LlRvSW50MzIoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdBcnJheUJ1ZmZlclZpZXcgc2l6ZSBpcyBub3QgYSBzbWFsbCBlbm91Z2ggcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IHRoaXMubGVuZ3RoICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcgJiYgYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yID09PSBjdG9yKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdG9yKFR5cGVkQXJyYXkgYXJyYXkpXG4gICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdO1xuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSB0aGlzLmxlbmd0aCAqIHRoaXMuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9zZXR0ZXIoaSwgYXJyYXkuX2dldHRlcihpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgIShhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBFQ01BU2NyaXB0LkNsYXNzKGFyZ3VtZW50c1swXSkgPT09ICdBcnJheUJ1ZmZlcicpKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdG9yKHNlcXVlbmNlPHR5cGU+IGFycmF5KVxuICAgICAgICBzZXF1ZW5jZSA9IGFyZ3VtZW50c1swXTtcblxuICAgICAgICB0aGlzLmxlbmd0aCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoc2VxdWVuY2UubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gdGhpcy5sZW5ndGggKiB0aGlzLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLmJ5dGVPZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgcyA9IHNlcXVlbmNlW2ldO1xuICAgICAgICAgIHRoaXMuX3NldHRlcihpLCBOdW1iZXIocykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBFQ01BU2NyaXB0LkNsYXNzKGFyZ3VtZW50c1swXSkgPT09ICdBcnJheUJ1ZmZlcicpKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdG9yKEFycmF5QnVmZmVyIGJ1ZmZlcixcbiAgICAgICAgLy8gICAgICAgICAgICAgb3B0aW9uYWwgdW5zaWduZWQgbG9uZyBieXRlT2Zmc2V0LCBvcHRpb25hbCB1bnNpZ25lZCBsb25nIGxlbmd0aClcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG5cbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihieXRlT2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuYnl0ZU9mZnNldCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImJ5dGVPZmZzZXQgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYnl0ZU9mZnNldCAlIHRoaXMuQllURVNfUEVSX0VMRU1FTlQpIHtcbiAgICAgICAgICAvLyBUaGUgZ2l2ZW4gYnl0ZU9mZnNldCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgICAvLyBzaXplIG9mIHRoZSBzcGVjaWZpYyB0eXBlLCBvdGhlcndpc2UgYW4gZXhjZXB0aW9uIGlzIHJhaXNlZC5cbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkFycmF5QnVmZmVyIGxlbmd0aCBtaW51cyB0aGUgYnl0ZU9mZnNldCBpcyBub3QgYSBtdWx0aXBsZSBvZiB0aGUgZWxlbWVudCBzaXplLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggLSB0aGlzLmJ5dGVPZmZzZXQ7XG5cbiAgICAgICAgICBpZiAodGhpcy5ieXRlTGVuZ3RoICUgdGhpcy5CWVRFU19QRVJfRUxFTUVOVCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJsZW5ndGggb2YgYnVmZmVyIG1pbnVzIGJ5dGVPZmZzZXQgbm90IGEgbXVsdGlwbGUgb2YgdGhlIGVsZW1lbnQgc2l6ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGggLyB0aGlzLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihsZW5ndGgpO1xuICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IHRoaXMubGVuZ3RoICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgodGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5ieXRlTGVuZ3RoKSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImJ5dGVPZmZzZXQgYW5kIGxlbmd0aCByZWZlcmVuY2UgYW4gYXJlYSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudCB0eXBlKHMpXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY3RvcjtcblxuICAgICAgY29uZmlndXJlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgIG1ha2VBcnJheUFjY2Vzc29ycyh0aGlzKTtcbiAgICB9O1xuXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgQXJyYXlCdWZmZXJWaWV3KCk7XG4gICAgY3Rvci5wcm90b3R5cGUuQllURVNfUEVSX0VMRU1FTlQgPSBieXRlc1BlckVsZW1lbnQ7XG4gICAgY3Rvci5wcm90b3R5cGUuX3BhY2sgPSBwYWNrO1xuICAgIGN0b3IucHJvdG90eXBlLl91bnBhY2sgPSB1bnBhY2s7XG4gICAgY3Rvci5CWVRFU19QRVJfRUxFTUVOVCA9IGJ5dGVzUGVyRWxlbWVudDtcblxuICAgIC8vIGdldHRlciB0eXBlICh1bnNpZ25lZCBsb25nIGluZGV4KTtcbiAgICBjdG9yLnByb3RvdHlwZS5fZ2V0dGVyID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm90IGVub3VnaCBhcmd1bWVudHNcIik7XG5cbiAgICAgIGluZGV4ID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihpbmRleCk7XG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ5dGVzID0gW10sIGksIG87XG4gICAgICBmb3IgKGkgPSAwLCBvID0gdGhpcy5ieXRlT2Zmc2V0ICsgaW5kZXggKiB0aGlzLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICAgICBpIDwgdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgICAgaSArPSAxLCBvICs9IDEpIHtcbiAgICAgICAgYnl0ZXMucHVzaCh0aGlzLmJ1ZmZlci5fYnl0ZXNbb10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3VucGFjayhieXRlcyk7XG4gICAgfTtcblxuICAgIC8vIE5PTlNUQU5EQVJEOiBjb252ZW5pZW5jZSBhbGlhcyBmb3IgZ2V0dGVyOiB0eXBlIGdldCh1bnNpZ25lZCBsb25nIGluZGV4KTtcbiAgICBjdG9yLnByb3RvdHlwZS5nZXQgPSBjdG9yLnByb3RvdHlwZS5fZ2V0dGVyO1xuXG4gICAgLy8gc2V0dGVyIHZvaWQgKHVuc2lnbmVkIGxvbmcgaW5kZXgsIHR5cGUgdmFsdWUpO1xuICAgIGN0b3IucHJvdG90eXBlLl9zZXR0ZXIgPSBmdW5jdGlvbihpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm90IGVub3VnaCBhcmd1bWVudHNcIik7XG5cbiAgICAgIGluZGV4ID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihpbmRleCk7XG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ5dGVzID0gdGhpcy5fcGFjayh2YWx1ZSksIGksIG87XG4gICAgICBmb3IgKGkgPSAwLCBvID0gdGhpcy5ieXRlT2Zmc2V0ICsgaW5kZXggKiB0aGlzLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICAgICBpIDwgdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgICAgaSArPSAxLCBvICs9IDEpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuX2J5dGVzW29dID0gYnl0ZXNbaV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHZvaWQgc2V0KFR5cGVkQXJyYXkgYXJyYXksIG9wdGlvbmFsIHVuc2lnbmVkIGxvbmcgb2Zmc2V0KTtcbiAgICAvLyB2b2lkIHNldChzZXF1ZW5jZTx0eXBlPiBhcnJheSwgb3B0aW9uYWwgdW5zaWduZWQgbG9uZyBvZmZzZXQpO1xuICAgIGN0b3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJOb3QgZW5vdWdoIGFyZ3VtZW50c1wiKTtcbiAgICAgIHZhciBhcnJheSwgc2VxdWVuY2UsIG9mZnNldCwgbGVuLFxuICAgICAgICAgIGksIHMsIGQsXG4gICAgICAgICAgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCwgdG1wO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcgJiYgYXJndW1lbnRzWzBdLmNvbnN0cnVjdG9yID09PSB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIC8vIHZvaWQgc2V0KFR5cGVkQXJyYXkgYXJyYXksIG9wdGlvbmFsIHVuc2lnbmVkIGxvbmcgb2Zmc2V0KTtcbiAgICAgICAgYXJyYXkgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIG9mZnNldCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoYXJndW1lbnRzWzFdKTtcblxuICAgICAgICBpZiAob2Zmc2V0ICsgYXJyYXkubGVuZ3RoID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk9mZnNldCBwbHVzIGxlbmd0aCBvZiBhcnJheSBpcyBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIH1cblxuICAgICAgICBieXRlT2Zmc2V0ID0gdGhpcy5ieXRlT2Zmc2V0ICsgb2Zmc2V0ICogdGhpcy5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgYnl0ZUxlbmd0aCA9IGFycmF5Lmxlbmd0aCAqIHRoaXMuQllURVNfUEVSX0VMRU1FTlQ7XG5cbiAgICAgICAgaWYgKGFycmF5LmJ1ZmZlciA9PT0gdGhpcy5idWZmZXIpIHtcbiAgICAgICAgICB0bXAgPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzID0gYXJyYXkuYnl0ZU9mZnNldDsgaSA8IGJ5dGVMZW5ndGg7IGkgKz0gMSwgcyArPSAxKSB7XG4gICAgICAgICAgICB0bXBbaV0gPSBhcnJheS5idWZmZXIuX2J5dGVzW3NdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGkgPSAwLCBkID0gYnl0ZU9mZnNldDsgaSA8IGJ5dGVMZW5ndGg7IGkgKz0gMSwgZCArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5fYnl0ZXNbZF0gPSB0bXBbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaSA9IDAsIHMgPSBhcnJheS5ieXRlT2Zmc2V0LCBkID0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgICAgIGkgPCBieXRlTGVuZ3RoOyBpICs9IDEsIHMgKz0gMSwgZCArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5fYnl0ZXNbZF0gPSBhcnJheS5idWZmZXIuX2J5dGVzW3NdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYXJndW1lbnRzWzBdLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gdm9pZCBzZXQoc2VxdWVuY2U8dHlwZT4gYXJyYXksIG9wdGlvbmFsIHVuc2lnbmVkIGxvbmcgb2Zmc2V0KTtcbiAgICAgICAgc2VxdWVuY2UgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGxlbiA9IEVDTUFTY3JpcHQuVG9VaW50MzIoc2VxdWVuY2UubGVuZ3RoKTtcbiAgICAgICAgb2Zmc2V0ID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihhcmd1bWVudHNbMV0pO1xuXG4gICAgICAgIGlmIChvZmZzZXQgKyBsZW4gPiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiT2Zmc2V0IHBsdXMgbGVuZ3RoIG9mIGFycmF5IGlzIG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHMgPSBzZXF1ZW5jZVtpXTtcbiAgICAgICAgICB0aGlzLl9zZXR0ZXIob2Zmc2V0ICsgaSwgTnVtYmVyKHMpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnQgdHlwZShzKVwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gVHlwZWRBcnJheSBzdWJhcnJheShsb25nIGJlZ2luLCBvcHRpb25hbCBsb25nIGVuZCk7XG4gICAgY3Rvci5wcm90b3R5cGUuc3ViYXJyYXkgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkgeyByZXR1cm4gdiA8IG1pbiA/IG1pbiA6IHYgPiBtYXggPyBtYXggOiB2OyB9XG5cbiAgICAgIHN0YXJ0ID0gRUNNQVNjcmlwdC5Ub0ludDMyKHN0YXJ0KTtcbiAgICAgIGVuZCA9IEVDTUFTY3JpcHQuVG9JbnQzMihlbmQpO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHsgc3RhcnQgPSAwOyB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHsgZW5kID0gdGhpcy5sZW5ndGg7IH1cblxuICAgICAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQ7IH1cbiAgICAgIGlmIChlbmQgPCAwKSB7IGVuZCA9IHRoaXMubGVuZ3RoICsgZW5kOyB9XG5cbiAgICAgIHN0YXJ0ID0gY2xhbXAoc3RhcnQsIDAsIHRoaXMubGVuZ3RoKTtcbiAgICAgIGVuZCA9IGNsYW1wKGVuZCwgMCwgdGhpcy5sZW5ndGgpO1xuXG4gICAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgICBpZiAobGVuIDwgMCkge1xuICAgICAgICBsZW4gPSAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoXG4gICAgICAgIHRoaXMuYnVmZmVyLCB0aGlzLmJ5dGVPZmZzZXQgKyBzdGFydCAqIHRoaXMuQllURVNfUEVSX0VMRU1FTlQsIGxlbik7XG4gICAgfTtcblxuICAgIHJldHVybiBjdG9yO1xuICB9XG5cbiAgdmFyIEludDhBcnJheSA9IG1ha2VDb25zdHJ1Y3RvcigxLCBwYWNrSTgsIHVucGFja0k4KTtcbiAgdmFyIFVpbnQ4QXJyYXkgPSBtYWtlQ29uc3RydWN0b3IoMSwgcGFja1U4LCB1bnBhY2tVOCk7XG4gIHZhciBVaW50OENsYW1wZWRBcnJheSA9IG1ha2VDb25zdHJ1Y3RvcigxLCBwYWNrVThDbGFtcGVkLCB1bnBhY2tVOCk7XG4gIHZhciBJbnQxNkFycmF5ID0gbWFrZUNvbnN0cnVjdG9yKDIsIHBhY2tJMTYsIHVucGFja0kxNik7XG4gIHZhciBVaW50MTZBcnJheSA9IG1ha2VDb25zdHJ1Y3RvcigyLCBwYWNrVTE2LCB1bnBhY2tVMTYpO1xuICB2YXIgSW50MzJBcnJheSA9IG1ha2VDb25zdHJ1Y3Rvcig0LCBwYWNrSTMyLCB1bnBhY2tJMzIpO1xuICB2YXIgVWludDMyQXJyYXkgPSBtYWtlQ29uc3RydWN0b3IoNCwgcGFja1UzMiwgdW5wYWNrVTMyKTtcbiAgdmFyIEZsb2F0MzJBcnJheSA9IG1ha2VDb25zdHJ1Y3Rvcig0LCBwYWNrRjMyLCB1bnBhY2tGMzIpO1xuICB2YXIgRmxvYXQ2NEFycmF5ID0gbWFrZUNvbnN0cnVjdG9yKDgsIHBhY2tGNjQsIHVucGFja0Y2NCk7XG5cbiAgZXhwb3J0cy5JbnQ4QXJyYXkgPSBleHBvcnRzLkludDhBcnJheSB8fCBJbnQ4QXJyYXk7XG4gIGV4cG9ydHMuVWludDhBcnJheSA9IGV4cG9ydHMuVWludDhBcnJheSB8fCBVaW50OEFycmF5O1xuICBleHBvcnRzLlVpbnQ4Q2xhbXBlZEFycmF5ID0gZXhwb3J0cy5VaW50OENsYW1wZWRBcnJheSB8fCBVaW50OENsYW1wZWRBcnJheTtcbiAgZXhwb3J0cy5JbnQxNkFycmF5ID0gZXhwb3J0cy5JbnQxNkFycmF5IHx8IEludDE2QXJyYXk7XG4gIGV4cG9ydHMuVWludDE2QXJyYXkgPSBleHBvcnRzLlVpbnQxNkFycmF5IHx8IFVpbnQxNkFycmF5O1xuICBleHBvcnRzLkludDMyQXJyYXkgPSBleHBvcnRzLkludDMyQXJyYXkgfHwgSW50MzJBcnJheTtcbiAgZXhwb3J0cy5VaW50MzJBcnJheSA9IGV4cG9ydHMuVWludDMyQXJyYXkgfHwgVWludDMyQXJyYXk7XG4gIGV4cG9ydHMuRmxvYXQzMkFycmF5ID0gZXhwb3J0cy5GbG9hdDMyQXJyYXkgfHwgRmxvYXQzMkFycmF5O1xuICBleHBvcnRzLkZsb2F0NjRBcnJheSA9IGV4cG9ydHMuRmxvYXQ2NEFycmF5IHx8IEZsb2F0NjRBcnJheTtcbn0oKSk7XG5cbi8vXG4vLyA2IFRoZSBEYXRhVmlldyBWaWV3IFR5cGVcbi8vXG5cbihmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gcihhcnJheSwgaW5kZXgpIHtcbiAgICByZXR1cm4gRUNNQVNjcmlwdC5Jc0NhbGxhYmxlKGFycmF5LmdldCkgPyBhcnJheS5nZXQoaW5kZXgpIDogYXJyYXlbaW5kZXhdO1xuICB9XG5cbiAgdmFyIElTX0JJR19FTkRJQU4gPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHUxNmFycmF5ID0gbmV3KGV4cG9ydHMuVWludDE2QXJyYXkpKFsweDEyMzRdKSxcbiAgICAgICAgdThhcnJheSA9IG5ldyhleHBvcnRzLlVpbnQ4QXJyYXkpKHUxNmFycmF5LmJ1ZmZlcik7XG4gICAgcmV0dXJuIHIodThhcnJheSwgMCkgPT09IDB4MTI7XG4gIH0oKSk7XG5cbiAgLy8gQ29uc3RydWN0b3IoQXJyYXlCdWZmZXIgYnVmZmVyLFxuICAvLyAgICAgICAgICAgICBvcHRpb25hbCB1bnNpZ25lZCBsb25nIGJ5dGVPZmZzZXQsXG4gIC8vICAgICAgICAgICAgIG9wdGlvbmFsIHVuc2lnbmVkIGxvbmcgYnl0ZUxlbmd0aClcbiAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICB2YXIgRGF0YVZpZXcgPSBmdW5jdGlvbiBEYXRhVmlldyhidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYnVmZmVyID0gbmV3IGV4cG9ydHMuQXJyYXlCdWZmZXIoMCk7XG4gICAgfSBlbHNlIGlmICghKGJ1ZmZlciBpbnN0YW5jZW9mIGV4cG9ydHMuQXJyYXlCdWZmZXIgfHwgRUNNQVNjcmlwdC5DbGFzcyhidWZmZXIpID09PSAnQXJyYXlCdWZmZXInKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlR5cGVFcnJvclwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlciB8fCBuZXcgZXhwb3J0cy5BcnJheUJ1ZmZlcigwKTtcblxuICAgIHRoaXMuYnl0ZU9mZnNldCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKHRoaXMuYnl0ZU9mZnNldCA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYnl0ZU9mZnNldCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICB0aGlzLmJ5dGVMZW5ndGggPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoIC0gdGhpcy5ieXRlT2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ5dGVMZW5ndGggPSBFQ01BU2NyaXB0LlRvVWludDMyKGJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIGlmICgodGhpcy5ieXRlT2Zmc2V0ICsgdGhpcy5ieXRlTGVuZ3RoKSA+IHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYnl0ZU9mZnNldCBhbmQgbGVuZ3RoIHJlZmVyZW5jZSBhbiBhcmVhIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBidWZmZXJcIik7XG4gICAgfVxuXG4gICAgY29uZmlndXJlUHJvcGVydGllcyh0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlR2V0dGVyKGFycmF5VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihieXRlT2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcblxuICAgICAgYnl0ZU9mZnNldCA9IEVDTUFTY3JpcHQuVG9VaW50MzIoYnl0ZU9mZnNldCk7XG5cbiAgICAgIGlmIChieXRlT2Zmc2V0ICsgYXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UID4gdGhpcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXJyYXkgaW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgfVxuICAgICAgYnl0ZU9mZnNldCArPSB0aGlzLmJ5dGVPZmZzZXQ7XG5cbiAgICAgIHZhciB1aW50OEFycmF5ID0gbmV3IGV4cG9ydHMuVWludDhBcnJheSh0aGlzLmJ1ZmZlciwgYnl0ZU9mZnNldCwgYXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UKSxcbiAgICAgICAgICBieXRlcyA9IFtdLCBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVzLnB1c2gocih1aW50OEFycmF5LCBpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChCb29sZWFuKGxpdHRsZUVuZGlhbikgPT09IEJvb2xlYW4oSVNfQklHX0VORElBTikpIHtcbiAgICAgICAgYnl0ZXMucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcihuZXcgYXJyYXlUeXBlKG5ldyBleHBvcnRzLlVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlciksIDApO1xuICAgIH07XG4gIH1cblxuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDggPSBtYWtlR2V0dGVyKGV4cG9ydHMuVWludDhBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQ4ID0gbWFrZUdldHRlcihleHBvcnRzLkludDhBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50MTYgPSBtYWtlR2V0dGVyKGV4cG9ydHMuVWludDE2QXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MTYgPSBtYWtlR2V0dGVyKGV4cG9ydHMuSW50MTZBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50MzIgPSBtYWtlR2V0dGVyKGV4cG9ydHMuVWludDMyQXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuZ2V0SW50MzIgPSBtYWtlR2V0dGVyKGV4cG9ydHMuSW50MzJBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDMyID0gbWFrZUdldHRlcihleHBvcnRzLkZsb2F0MzJBcnJheSk7XG4gIERhdGFWaWV3LnByb3RvdHlwZS5nZXRGbG9hdDY0ID0gbWFrZUdldHRlcihleHBvcnRzLkZsb2F0NjRBcnJheSk7XG5cbiAgZnVuY3Rpb24gbWFrZVNldHRlcihhcnJheVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYnl0ZU9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuXG4gICAgICBieXRlT2Zmc2V0ID0gRUNNQVNjcmlwdC5Ub1VpbnQzMihieXRlT2Zmc2V0KTtcbiAgICAgIGlmIChieXRlT2Zmc2V0ICsgYXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UID4gdGhpcy5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXJyYXkgaW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBHZXQgYnl0ZXNcbiAgICAgIHZhciB0eXBlQXJyYXkgPSBuZXcgYXJyYXlUeXBlKFt2YWx1ZV0pLFxuICAgICAgICAgIGJ5dGVBcnJheSA9IG5ldyBleHBvcnRzLlVpbnQ4QXJyYXkodHlwZUFycmF5LmJ1ZmZlciksXG4gICAgICAgICAgYnl0ZXMgPSBbXSwgaSwgYnl0ZVZpZXc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7IGkgKz0gMSkge1xuICAgICAgICBieXRlcy5wdXNoKHIoYnl0ZUFycmF5LCBpKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZsaXAgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoQm9vbGVhbihsaXR0bGVFbmRpYW4pID09PSBCb29sZWFuKElTX0JJR19FTkRJQU4pKSB7XG4gICAgICAgIGJ5dGVzLnJldmVyc2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gV3JpdGUgdGhlbVxuICAgICAgYnl0ZVZpZXcgPSBuZXcgZXhwb3J0cy5VaW50OEFycmF5KHRoaXMuYnVmZmVyLCBieXRlT2Zmc2V0LCBhcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgICAgYnl0ZVZpZXcuc2V0KGJ5dGVzKTtcbiAgICB9O1xuICB9XG5cbiAgRGF0YVZpZXcucHJvdG90eXBlLnNldFVpbnQ4ID0gbWFrZVNldHRlcihleHBvcnRzLlVpbnQ4QXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0SW50OCA9IG1ha2VTZXR0ZXIoZXhwb3J0cy5JbnQ4QXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0VWludDE2ID0gbWFrZVNldHRlcihleHBvcnRzLlVpbnQxNkFycmF5KTtcbiAgRGF0YVZpZXcucHJvdG90eXBlLnNldEludDE2ID0gbWFrZVNldHRlcihleHBvcnRzLkludDE2QXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0VWludDMyID0gbWFrZVNldHRlcihleHBvcnRzLlVpbnQzMkFycmF5KTtcbiAgRGF0YVZpZXcucHJvdG90eXBlLnNldEludDMyID0gbWFrZVNldHRlcihleHBvcnRzLkludDMyQXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0RmxvYXQzMiA9IG1ha2VTZXR0ZXIoZXhwb3J0cy5GbG9hdDMyQXJyYXkpO1xuICBEYXRhVmlldy5wcm90b3R5cGUuc2V0RmxvYXQ2NCA9IG1ha2VTZXR0ZXIoZXhwb3J0cy5GbG9hdDY0QXJyYXkpO1xuXG4gIGV4cG9ydHMuRGF0YVZpZXcgPSBleHBvcnRzLkRhdGFWaWV3IHx8IERhdGFWaWV3O1xuXG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/typedarray/index.js\n");

/***/ })

};
;